状态模式（State Pattern）是一种行为设计模式，它允许一个对象在其内部状态改变时改变它的行为。
这个对象看起来好像修改了它的类。

在状态模式中，类的行为是由状态决定的，并在运行时根据对象的状态来改变其行为。这个模式特别适用于那些对象的行为依赖于其状态，并且可以在运行时动态改变行为的场景。

### 核心组成

状态模式主要由以下几个角色构成：

1. **上下文（Context）**：
   - 这是用户和系统交互的主体，它持有一个指向状态对象的引用，用以定义当前状态。
   - 上下文将与状态相关的行为委托给当前的状态对象来处理。
   - 上下文需要有一个方法来允许状态对象自行更换上下文中的当前状态。

2. **抽象状态（State）**：
   - 定义一个接口以封装与上下文的一个特定状态相关的行为。
   - 可以有一个或多个具体实现该接口的具体状态类。

3. **具体状态（Concrete States）**：
   - 这些类实现了抽象状态接口，提供了用于处理来自上下文的请求的具体行为。
   - 每个类对应一种实际的状态，并且可以实现在该状态下应该如何处理上下文的请求。
   - 具体状态类也可以在必要时改变上下文中的当前状态，转移至另一个具体状态。

### 工作原理

- 上下文通常会有一个设置状态的方法，用于改变当前的状态对象。
- 当上下文的内部状态改变时，上下文会更换它所用的状态对象。
- 上下文会把状态相关的行为委托给当前关联的状态对象来执行。
- 每一个具体状态类都包含了当处于该状态时所应有的行为，因此当上下文的状态改变时，其行为也随之改变。

### 应用场景

状态模式适用于以下场景：

- 当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时。
- 当一个操作中含有庞大的多分支的条件语句，这些分支依赖于该对象的状态。状态模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。

### 优点

- 封装了转换规则。
- 枚举可能的状态，在枚举状态之前需要了解状态以及它们之间的转换关系。
- 将所有与某个状态有关的行为放到一个类中。
- 允许状态转换逻辑与状态对象合成一体。
- 可以让多个上下文对象共享一个状态对象，减少对象的数量。

### 缺点

- 如果状态多且频繁变更，会导致有很多的状态类，增加系统的复杂度。
- 应用不当会导致逻辑与数据的混乱，比如状态类间可以互相引用导致系统行为难以预测。

状态模式提供了一种清晰而简洁的方式来表示有限状态机。这些状态机常常存在于各种软件工程问题中，如游戏开发、工作流引擎、用户界面设计等领域。通过使用状态模式，可以避免长长的条件选择语句，并且可以更容易地添加新状态。